function [rx,rb, r_rxrb, ave_r, ave_rsoc] = rsocsim1(ncells,ntrials,rmax,epsilon)% RSOCSIM1 performs a numerical simulation of superneuron superantineuron%	by generating a random covariance structure such that the pairwise%	r values are on the range 0..rmax.  There are nells neurons and ncells%	antineurons.  Antineurons are assumed to have the same covariance%	structure as the neurons . . . but I intend to elaborate this.%	The routine generates ntrials of data and assigns a behavior %	(1 or 0) if the sum of neurons > sum of antineurons, for each%	trial.  The rSOC is the correlation coefficient between the%	neuron and behavior.  This is returned as row vector rb.%	A unit's average correlation with all the other units is %	intended to reflect its degree of connectivity and is returned%	as row vector rx.  The correlation between degree of %	connectivity and rSOC is the correlation coefficient between%	rx and rb.  It is returned as scalar r_rxrb.%	Finally, the mean r value between all pairs is ave_r. %	The mean rSOC is returned as ave_rSOC.%	Usage: [rx,rb, r_rxrb, ave_r, ave_rsoc] = rsocsim1(ncells,ntrials,rmax,epsilon)%% ncells = 100;n = ntrials;% rancorrelmtx is a function I wrote.C = rancorrelmtx(ncells,rmax);Q = sqrtm(C);X = Q * randn(ncells,n);Y = Q * randn(ncells,n);% b is a row vector that is 1 if the column of unit responses in X is% larger than the sum over the corresponding column of Y.  It is behavior.b = sum(X) > sum(Y);% Xb concatenates the behavior row on the unit responsesXb = [X; b];Cx = corrcoef(Xb');rb = Cx(ncells+1,1:ncells);ave_rsoc = mean(rb);ave_r = (sum(sum(Cx(1:ncells,1:ncells))) - ncells) / (ncells^2 - ncells);fprintf('Mean SOC r = %g\n', ave_rsoc);fprintf('Mean r value between all pairs = %g\n', ave_r);% rb is a row vector that contains the r values between the units and% neural responses.rx = (sum(Cx(1:ncells,1:ncells)) - 1) / (ncells - 1);rxe = (sum(C) - 1) / (ncells - 1);% rx is a row vector representing the average r value for each cell.% This is computed from the actual covariance matrix.  Notice that% the unity term is subtracted and the the number of correlations is% ncells - 1.% rxe is the corresponding row vector for the expected average correlation.%  We use the desired covariance matrix C for this.  We can get away with%  this because the covariance matrix is the correlation matrix as we assume%  unity variance on all terms.% There are 2 types of mean square errors we could obtain, mse1 compares% the mean r values.  mse2 compares the individual r values.% Uncomment these if you want to see them.  I have reassured myself% that the mean error is quite low (on order of 1-5%) when 100 or more% trials are used.% mse1 = sum((rxe-rx).^2) / ncells;% mse2 = sum(sum((Cx(1:ncells,1:ncells) - C).^2)) / (ncells^2);h1 = corrcoef([rx;rb]');fprintf('Correlation coefficient between a unit''s average r and its SOCr = %g\n', h1(1,2));r_rxrb = h1(1,2);