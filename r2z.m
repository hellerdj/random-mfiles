function [z1,z2,p] = r2z(r1,r2,n1,n2)% computes Fisher's z-transformation of the correlation coefficient% Usage: z = r2z(r) % r can be a scalar or matrix.  The return val, z, will have% the same dimensions as r.%% Alternatively, %  [z1,z2,p] = r2z(r1,r2,n1,n2)%  calculates z1 and z2  for two sets of  rvals%  s.  These values are useful for comparing whether two r vals are%  different. To compute these, we also need to know how many observations%  went into the calculation of r.  If n1 is a scalar, then it is assumed to%  apply to all members of r1. Same for n2.  Otherwise these matrices must%  be of the same dimensions of r1 and r2.% Finally,%  [z,zbar,p] = r2z(r,n,rtrue)% returns the z as well as the probability, p, of obtaining r when the true% value is rtrue. n is the number of ordered pairs.  n can be a scalar or% a vector of the same dimension as r.  r2z(r,n) assumes rtrue is zero.% % see Numerical Recipes, 2nd Edition, p.637% 11/5/96 mns wrote it% 7/1/97  mns added options for 3 argument versionif nargin < 1  error('r2z requires at least 1 argument')end if nargin < 2  if nargout > 1    error('Too many output args')  endelseif nargin==2  % we are comparing r to the null hypothesis that rtrue is 0  rtrue = 0;  n = r2;				% 2nd arg is number of obselseif nargin==3  n = r2;  rtrue = n1;				% 3rd arg is rtrueend% $$$ if nargout > 1% $$$   if nargin ~= 4% $$$     error('r2z: wrong combo of arguments. type ''help r2z'' ')% $$$   end% $$$ endz1 = 0.5 * log( (1+r1) ./ (1-r1) );if nargin == 1  return				% we're doneelseif nargin < 4  % single r value tested agains rtrue  zbar = .5*(log((1+rtrue)/(1-rtrue)) + rtrue./(n-1));  z2 = zbar;				% return this   p = erfc(abs(z1-z2) .* sqrt(n-3) / sqrt(2));  else  if sum(size(r1)==size(r2))~=2    error('r2z: matrices must be same size')  end  if max(size(n1))==1    n1 = n1 * ones(size(r1));  elseif size(r1,1)~=size(n1,1) | size(r1,2)~=size(n1,2)    error('r2z: r and n must be same size matrices');  end  if max(size(n2))==1    n2 = n2 * ones(size(r2));  elseif size(r2,1)~=size(n2,1) | size(r2,2)~=size(n2,2)    error('r2z: r and n must be same size matrices');  end  z2 = 0.5 * log( (1+r2) ./ (1-r2) );  q = abs(z1-z2) ./ (sqrt(2) * sqrt((1./(n1-3)) + (1./(n2-3))));  p = erfc(q);end