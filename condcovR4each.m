function [cr, r, nanrows, m] = condcovR4each(X,y)% [cr r] = condcovR4each(X,y)% Computes the conditional correlation coefficient between each predictor,% represented by the columns of X, on the dependendent observations, Y.  Y% must be a column vector such that the rows of [X y] would define an% observation.  The routine returns a row vector, CR, whose elements% reflect the correlation between the columns of X and y, conditional on the% other terms.  The simple partial correlation coefficients are returned in% the second output, r.   If the data contain NaNs, the entire row is% deleted and its row number is returned in vector NANROWS.  If this leaves% too few observations for analysis, the routine returns row vectors of NaNs% of appropriate dimensions.  The number of observations used to make the% final correlation calcs is the 4th returned arg.  Note that% length(nanrows)+m should equal the number of rows in X.%% This is a great way to visualize the importance of one factor in the% presence of possible confounders.% 11/8/96  mns wrote it% 11/9/96  return vectors of nans if too many missing rows% 11/11/96 return number of obs too.Y = [y X];[m n] = size(Y);   % do any rows contain NaN?nanrows = find(any(isnan(Y'))');% If so, remove themif ~isempty(nanrows)  if length(nanrows) > m-n-3    sprintf('condcovR4each: too many missing cells (NaNs)')    cr = nan * ones(1,n-1);    r = nan * ones(1,n-1);    return;  else    Y(nanrows,:) = [];    % get dimensions of the revised array    [m n] = size(Y);  endendC = cov(Y);			% compute the covariance mtxpartialr = cov2r(C);			% return the r valuescols = 2:n;r = partialr(1,cols);			% simple correlation with yfor j = 1:length(cols)  % compute the conditional r value for jth predictor, holding all other  % terms constant   condr = cov2r(condcov(C,cols(cols~=cols(j))));  cr(j) = condr(1,2);end