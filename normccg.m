function [ccg,tau,Ttau,r,vmr] = normccg(u1,u2,tdur,epoch,res,noplot)% [ccg,tau,Ttau,r,vmr] = normccg(u1,u2,tdur,epoch,res)% computes the normalized ccg and acg(s) from spike trains in u1 and u2.% The spike trains are given as a vector of 1s and 0s.% Actually a vector of nonzeros and ones is fine too.% The routine parses this vector into epoch.  % tdur   -- length of the whole spike train vector in seconds% epoch  -- length of the epoch for analysis.  This need not be a trial.%           In fact a good value is 0.1 sec. % res    -- resolution of the spike train.  0.001 usually.% noplot -- optional arg. If set, then suppresses plotting of ccg% Note,%% If your spike data is organized by trials, but in 1s and 0s, just % get the matrix so that columns are the trials and then use the x(:) syntax% to make a long vector. This will work provide that your epoch duration % divides evenly into the trial length.  The first thing the routine does is% to organize the data into a new matrix in which rows are epochs.%% If your data is a sequence of spike arrival times, the best bet is to% round to milliseconds and use these to index a vector of msec bins.% History%% 6/96 mns wrote it following Wyeth's appendix. % 9/1/96 mns added help% Make n rows of spike arrival timesn = tdur/epoch;% should probably check for errors on odd epoch lengths here and produce% an error message if non-integral% the U1out etc. may not contain 1's and 0's but spike times and 0's% We want onesx1 = reshape(u1~=0,epoch/res,n)';x2 = reshape(u2~=0,epoch/res,n)';% num of spikes in an epoch is sum of nonzero times in the row.spcounts = [sum(x1')' sum(x2')'];mcount = mean(spcounts);vcount = std(spcounts) .^ 2;vmr = vcount ./ mcount;T = size(x1,2);N1 = sum(x1')';N2 = sum(x2')';r = munique(diag(corrcoef([N1 N2]),-1));% Expectations%  For N_k this is a scalarE_N1 = mean(N1);E_N2 = mean(N2);lam1 = E_N1/T;lam2 = E_N2/T;Ttau = T-abs(-epoch/res:epoch/res);Ttau(find(Ttau==0)) = nan * ones(size(Ttau(find(Ttau==0))));padx1 = [zeros(size(x1,1),epoch/res) x1 zeros(size(x1,1),epoch/res)];padx2 = [zeros(size(x2,1),epoch/res) x2 zeros(size(x2,1),epoch/res)];for tau = -epoch/res:epoch/res  E_S_x1x2tau(epoch/res+1+tau) = mean(nansum((padx1(:,epoch/res+tau+1:T+epoch/res+tau) .* padx2(:,epoch/res+1:epoch/res+T))'));endtau = -epoch:res:epoch;% plot(tau,Ttau)ccg = (1./(lam1*lam2*Ttau)) .* E_S_x1x2tau;if nargin < 6  plot(tau,ccg)end% t = [-epoch+res:res:epoch-res]';