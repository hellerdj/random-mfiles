function [r,rvect] = ccgacg2r(ccg,acg1,acg2,tau,epochlen)% takes a the normalized cross correlogram and autocorrelograms produced by% normccg.m and returns the r value computed from the areas.  The algorithm% was provided by W. Bair and H. Sompolinsky. % Inputs%   ccg, acg1, acg2 -- row vectors representing cross- and the two%                    auto-correlograms. %   tau -- corresponding row vetor of time lags%   epochlen -- optional vector containing epoch durations for calculating the%             r value within plus minus this duration from 0.  These refer%             to values on tau. % Output%   r -- calculated from the whole epoch%   rvect -- calculated for each member of epochlen%% History% 9/9/96 mns wrote itT = (length(tau)-1)/2;tt = -T:T;Ttau = T-abs(tt);% Ttau(find(Ttau==0)) = nan * ones(size(Ttau(find(Ttau==0))));% compute the areaccgAtot = nansum(Ttau.*(ccg - 1));acg1Atot = nansum(Ttau.*(acg1-1));acg2Atot = nansum(Ttau.*(acg2-1));r =  ccgAtot / sqrt(acg1Atot * acg2Atot);if nargin > 4  for i = 1:length(epochlen)    t5 = find(abs(tau)<=epochlen(i));    ccgA5 = nansum(Ttau(t5) .* (ccg(t5)-1));    acg1A5 = nansum(Ttau(t5) .* (acg1(t5)-1));    acg2A5 = nansum(Ttau(t5) .* (acg2(t5)-1));    rvect(i) = ccgA5 / sqrt(acg1A5 * acg2A5);  endend