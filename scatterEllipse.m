function [hPoints,hEllipse,hElaxes] = scatterEllipse(x,ns)% [hPoints,hEllipse,hElaxes] = scatterEllipse(x,ns)% Takes ordered pairs in N by 2 data matrix, x, and makes a scatterplot on% the current axes.  It shows the fitting ellipse and returns handles to% plotting objects.  This is just a quickie routine that I find handy.  The ellipse% has its axes scaled to NS stdevs of the principal components.  The default is% 1.% 7/8/98 mns spawned from test_princomp% I plan to generalize this (one day) to project n-dim ellipsoidsif nargin < 2  ns = 1;end [pc,score,latent,tsquare] = princomp(x);hPoints = plot(x(:,1), x(:,2),'o'),hold on% latent holds the variancesigma = sqrt(latent);h1=line(mean(x(:,1))+ns*sigma(1)*[0 pc(1,1)], mean(x(:,2))+ns*sigma(1) * [0 pc(2,1)])h2 = line(mean(x(:,1))-ns*sigma(1)*[0 pc(1,1)], mean(x(:,2))-ns*sigma(1) * [0 pc(2,1)])h3=line(mean(x(:,1))+ns*sigma(2)*[0 pc(1,2)], mean(x(:,2))+ns*sigma(2) * [0 pc(2,2)])h4 = line(mean(x(:,1))-ns*sigma(2)*[0 pc(1,2)], mean(x(:,2))-ns*sigma(2) * [0 pc(2,2)])hElaxes = [h1 h2 h3 h4];[xe ye] = ellipse(0,0,ns*sigma(1),ns*sigma(2));% hq = plot(xe,ye,'r')th = atan2(pc(2,1),pc(1,1));   % theta% th * 180/piq = mean(x);[er] = [xe' ye'] * [cos(th) sin(th); -sin(th) cos(th)] + ...    q(ones(size(xe',1),1),:);hEllipse = plot(er(:,1),er(:,2));hold off