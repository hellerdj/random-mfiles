function [Pxt1,Pxt2,Mxt1,Mxt2,Fp1,Fp2,Fm1,Fm2,Fx,Fy,Fte,Fto,xfax,yfax,tfax] = motionfilt3(x,y,t,cordx,csigx,gsigy,k)% [Pxt1,Pxt2,Mxt1,Mxt2,Fp1,Fp2,Fm1,Fm2,Fx,Fy,Fte,Fto,xfax,yfax,tfax] =...%          motionfilt3(x,y,t,cordx,csigx,gsigy,k,diam)% computes motion filters and their fourier transforms%% x  x axis      x = linspace(-1,1,nx)';% y  y axis      y = linspace(-1,1,ny)';% t  time axis  (must begin at 0)% cordx  cauchy order for x dimension% csigx  cauchy sigma for x dimension% gsigy  gaussian sigma for y dimension% k   time scale factor for Adelson-Bergen time filter (40 is good)% % Returns% ~~~~~~~% Pxt1   plus-x dir xyt filter (1). x by y by t dim% Pxt2   plus-x dir xyt filter (2). % Mxt1   minus-x dir xyt filter (1)% Mxt2   minus-x dir xyt filter (2)% Fp1    3-d FFT of Pxt1% Fp2    3-d FFT of Pxt2% Fm1    3-d FFT of Mxt1% Fm2    3-d FFT of Mxt2% Fx     1-d FFT of cauchy x (even), shifted so 0 is at center% Fy     1-d FFT of gaussian y, shifted so 0 is at center% Fte    1-d FFT of temporal function 1, shifted so 0 at center% Fto    1-d FFT of temporal function 2, shifted so 0 at center% xfax   1-d x frequency axis -- plot(xfax,Fx)% yfax   1-d y frequency axis -- plot(yfax,Fy) % tfax   1-d t frequency axis -- plot(tfax,Fte) or plot(tfax,Fto)% 10/1/97 mns wrote it% $$$ % $$$ nx = 128; x = linspace(-2.5,2.5,nx)';% $$$ ny = 128; y = linspace(-2.5,2.5,ny)';% $$$ nt = 32; t = linspace(0,31/75,nt);% $$$ cordx = 4;% $$$ csigx = .2;% $$$ gsigy = .2;% $$$ k = 40;%% error('comment out debugging stuff')[qe qo] =  cauchy(x,0,csigx,cordx);% shift for discrete FFTxe = fftshift(qe);xo = fftshift(qo);% plot(x,xe,x,xo)% plot(x,fftshift(xe),x,fftshift(xo))Fx = fftshift(abs(fft(xe)));nyq = 128/(2*(max(x)-min(x)));			% nyquist% freq axisxfax = linspace(-nyq,((length(x)-2)/length(x))*nyq,length(x));	% plot(xfax,Fx)% set(gca,'XLim',[.1 10],'XScale','log')if isempty(k)  k=50;  % default Temporal scale factor endte = temp_imp_resp(5,k,t);to = temp_imp_resp(3,k,t);plot(t,te,t,to)% what's the difference between the peaks% t(find(te==max(te))) - t(find(to==max(to)))% t(find(te==min(te))) - t(find(to==min(to)))% plot(te)% plot(t,fftshift(te))tnyq = (length(t)/2) / max(t);% freq axis (approx)tfax = linspace(-tnyq,((length(t)-2)/length(t))*tnyq,length(t));Fte = fftshift(abs(fft(te)));Fto = fftshift(abs(fft(to)));% plot(tfax,Fte,tfax,Fto)% normalize based on amplitude spectrum ?? not sure this is a good ideaae = trapz(Fte);ao = trapz(Fto);te = te * ao/ae;Fte = fftshift(abs(fft(te)));% set(gca,'XLim',[.1 40],'XScale','log')% [te to] = cauchy(t,0,csigt,cordt);q = exp(-(y.^2) ./ (2*gsigy.^2));ye = fftshift(q);% plot(y,ye)% plot(y,fftshift(ye))Fy = fftshift(abs(fft(ye)));nyq = 128/(2*(max(y)-min(y)));			% nyquist% freq axisyfax = linspace(-nyq,((length(y)-2)/length(y))*nyq,length(y));	% plot(yfax,Fy)% plus x-t % $$$ % $$$ pxt1 = (to' * xe) + (te' * xo);% $$$ pxt2 = (to' * xo) - (te' * xe);% $$$ mxt1 = (to' * xe) - (te' * xo);% $$$ mxt2 = (to' * xo) + (te' * xe);% size(xe)% use ndgrid rather than meshgrid.  I think the documentation is wrong. When% I use meshgrid, the x dimension is along the rows.[qxe,qye,qte] = ndgrid(xe,ye,te);% size(qxe)% $$$  [xe qxe(:,2,4)]% $$$ [ye'; qye(1,:,1)]% $$$ all(ye' == qye(3,:,5))[qxo, qyo, qto] = ndgrid(xo,ye,to);% size(qxo)Pxt1 = (qye.*(qto.*qxe + qte.*qxo));Pxt2 = (qye.*(qto.*qxo - qte.*qxe));Mxt2 = (qye.*(qto.*qxo + qte.*qxe));Mxt1 = (qye.*(qto.*qxe - qte.*qxo));clear qx* qy*% let's look at fftFp1 = fftn(Pxt1);Fp2 = fftn(Pxt2);Fm1 = fftn(Mxt1);Fm2 = fftn(Mxt2);% $$$ colormap(gray)% $$$ % $$$ % on this plot, the time slices go from left to right.% $$$ imagesc(squeeze(Pxt1(:,8,:)))% $$$ imagesc(squeeze(Pxt2(:,1,:)))% $$$ imagesc(squeeze(Mxt1(:,1,:)))% $$$ imagesc(squeeze(Mxt2(:,1,:)))% $$$ ylabel('Space (x)')% $$$ xlabel('Time')% $$$ % $$$ x0 = round(nx/2)% $$$ m1 = zeros(size(Pxt1));% $$$ size(m1)% $$$ for i=1:nt% $$$   m1(x0-round(nt/2)+i,:,i)=1;% $$$ end% $$$ size(m1)% $$$ squeeze(m1(:,2,:))% $$$ imagesc(squeeze(m1(:,8,:)))% $$$ % $$$ % This step takes a hell of a long time!% $$$ cp1 = convn(m1,Pxt1,'same');% $$$ cp2 = convn(m1,Pxt2,'same');% $$$ cm1 = convn(m1,Mxt1,'same');% $$$ cm2 = convn(m1,Mxt2,'same');% $$$ % $$$ MEp = cp1.*cp1 + cp2.*cp2;% $$$ MEm = cm1.*cm1 + cm2.*cm2;% $$$ % $$$ % $$$ save mfilt3.mat cp* cm* m1 Mx* Px* xe xo te to ye x y t nx ny nt gsig* ...% $$$     csig* cord*% $$$ % $$$ %%%%%%%%%%%%%%%% $$$ % resume here %% $$$ %%%%%%%%%%%%%%%% $$$ % $$$ load mfilt3% $$$ % $$$ zmax = max([MEp(:); MEm(:)])% $$$ % $$$ % $$$ % This works!  Look at the output normalized to the max value.% $$$ % The value 64 in these expressions makes the the pos motion filter output% $$$ % look like the imagesc version% $$$ image(64 * squeeze(MEp(:,5,:))/zmax)% $$$ image(64 * squeeze(MEm(:,5,:))/zmax)% $$$ % $$$ % look at these individually normalized% $$$ imagesc(squeeze(MEp(:,5,:)))% $$$ imagesc(squeeze(MEm(:,5,:)))% $$$ Fmot = fftn(m1);% $$$ fmax = max(abs(Fp1(:)))% $$$ % $$$ % $$$ image(64 * fftshift(squeeze(abs(Fm1(:,15,:)))) / fmax)% $$$ imagesc(fftshift(squeeze(abs(Fmot(:,1,:)))))% $$$ % $$$ MEp_f = (ifftn(Fp1.*Fmot)).^2 + (ifftn(Fp2.*Fmot)).^2;% $$$ MEm_f = (ifftn(Fm1.*Fmot)).^2 + (ifftn(Fm2.*Fmot)).^2;% $$$ % imagesc(squeeze(real(MEp(:,5,:))))% $$$ % $$$ % You should not have to perform the fftshift step here, but it seems that% $$$ % in fact you must.% $$$ % $$$ fmax = max([real(MEp_f(:)); real(MEm_f(:))]) % $$$ imagesc(fftshift(squeeze(real(MEp_f(:,5,:)))))% $$$ imagesc(fftshift(squeeze(real(MEp_f(:,1,:)))))% $$$ imagesc(fftshift(squeeze(real(MEm_f(:,1,:)))))% $$$ image(64 * fftshift(squeeze(real(MEp_f(:,1,:)))) / fmax)% $$$ image(64 * fftshift(squeeze(real(MEm_f(:,1,:)))) / fmax)% $$$ % $$$ sum(real(MEp_f(:)))% $$$ sum(real(MEm_f(:)))% $$$ % $$$ size(Fp1)