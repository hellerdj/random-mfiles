function [tb,tact,snumb,snumact,p_burst] = hanes(s,duration,plotopt)% [tb,tact,snumb,snumact,p_burst] = hanes(s,duration)% % [t1,t2,n1,n2,si1,si2,h1,h2] = hanes(s)% Run the Hanes & Schall algorithm (Legendy and Salczman) on a spike train, s. % For the moment, s is in ms, not seconds -- needs to be changed% Input vals% ~~~~~~~~~~% s is a vector of spike times in ms -- I plan to change this% duration is optional duration of spikes in seconds.% plotopt is optional, set to 1 if you want to see the train.  Burst and% activation periods are shown.%% Return vals% ~~~~~~~~~~~% tb  times defining burst [beginning end]% tact times defining activation [beginning end]% sb spike number defining burst% sact spike numbers defining activation period% si1,si2  surprise indices%  h1, h2  true/false for significance% 11/4/96 mil wrote it  -- see spikes2.m% 11/5/96 mil & mns spawned hanes.m%makes a column vector of s and adds a %second column which includes the spike number.s = s(:);  	% guarantees s is a column vectorg=[s*.001 (1:length(s))'];	% we'll need this later%This is just a replica of g so that you can%go back later if you wish to see at what point in time the spikes occurred.s2=g;		% replica   -- ??? purpose???% User can supply the duration of the spike train epoch if it is known.% Otherwise it is taken as the interval from the 1st to last spike.  Note% that the spikes are in ms, but we will calculate in seconds.if nargin < 2  duration = (s(length(s))-s(1))/1000;elseif isempty(duration)  duration = (s(length(s))-s(1))/1000;endspikerate=length(s)/duration;isi = diff(s) * .001;% make a new matrix for calculating SI values as used by Hanes et al,1993% make a 2 column vector from isi by taking its% transpose.  The second column are the ACTUAL spikes numbered as they occur % in the train. It starts at 2 because 2 spikes must have occurred in order % to calculate the first isi value.a=[isi(:) (2:length(s))']; % Find first isi less than the expected val and lop off the array to that % pointq = min(find(a(:,1) <= 1/spikerate))if q > 1  a(1:q-1,:) = [];end% sum of isi's from start point to end is% the accumulated time in the spike train from our starting pointb=cumsum(a(:,1));   % As part of Hanes' algorithm, once you've gotten to the first isi that is <=% your predicted isi, you move on to the next spike and add that isi value% to T.  You need T to calculate the expected % number of spikes given the amount of time (your T value) that has passed.% c will be column 4 of data matrix containing the % spike number of the train.  % This is the number of spikes in the count that correspond to the % accumulated time to that point in the spike train.  % It starts at 2 because 2 spikes must have % occurred in order to calculate the first isi value in column 2c=(2:(size(b,1)+1))'; % probabilities of getting the number of% spikes in c or greater based on the Poisson distribution with % a mean spike rate (from the whole train) times the accumulated time% (added up isi's -- which is in b)d=1-(poisscdf(c,(spikerate*b)));   % requires stats toolboxe=-log(d(2:length(d)));		%Hanes SI index valuelikec = poisspdf(c,(spikerate*b));	% likelihood of counts -- from pdfif any(~finite(e))  % we have some extreme vals  % The biggest lies among the infinite  vals for e  j = ~finite(e);  % selection -- the max is among these  q = poisspdf(c(2:length(c)),(spikerate*b(2:length(b))));  % it is the val that is the min on the pdf  ibest = find(q ==  min(q(j)))+1;else  ibest = find(e == max(e(2:length(e))))+1;end	% The place where SI is maximal is the last spike of the burst.% According to Hanes' algorithm the very first SI value is excluded from % this search.  This is why the e vector is 1 cell shorter than the other % vectors (a,b,c,d,L).   Because I had to exclude the first cell I must add % 1 to ibest in order to obtain the correct spike number in vector a. endspike=a(ibest,2);% According to Hanes' I now am supposed to go to the very last spike in the % train and calculate SI for the T interval from the last spike to the% first spike after target presentation, which in this case is just % the first spike in the train.nspikes = length(s); ttot = 0.001 * (max(s ) - min(s));	% total duration in secnhat=spikerate*ttot; % Surprise index computed over all spikes in the train, and% its associated likelihood, p1si1 = -log(1-(poisscdf(nspikes,nhat)));p1 = poisspdf(nspikes,nhat);% $$$ si1 = -log(1-(poisscdf(length(s),estspike_count)));% $$$ p1 = poisspdf(length(s),estspike_count);% We now remove spikes from the beginning of the train% until we reach the spike defining the end of the burst (endspike)% Using the matrix, g, which you will recall is a copy of s in column 1% and the spike number in column 2,  we now delete all rows of g AFTER% the endspike row.  g0 = g;					% save a copy for later.g(find(g(:,2)==endspike)+1:length(g),:)=[];% Use this array to store the spike number, SI index, and pdf value% matt called this h in his code.% we're going to use this matrix to record our SI values that% we calculated as we continued to delete spikes from the beginning of the % train.  The highest number in row 1  corresponds to the% spike representing the end of the putative burst.si_tab = zeros(size(g,1),3);	% allocate the array -- 1 row for each spike% this is the SI that we calculated going from the last spike in% the spike train to the first spike in the train after target presentation% We already know everything for spike 1si_tab(1,:) = [1 si1 p1]; % We also know the value for the last spikesi_tab(endspike,:) = [endspike e(ibest) likec(ibest)];for i = 2:endspike-1  nsp = endspike - i + 1;   % number of spike from this point in train  ttot = g(endspike,1) - g(i,1);   % time left from this point to endspike  nhat = spikerate * ttot;  si_tab(i,:) = [i -log(1 - poisscdf(nsp,nhat)) poisspdf(nsp, nhat)];end% Find the biggest SI value, excluding the endspike.  This is supposed to % mark the beginning of the burst.  This would be easy except that sometimes% we get infinite values in the 2nd columnif any(~finite(si_tab(1:endspike-1,2)))  % we have some extreme vals  % The biggest lies among the infinite  vals in the 2nd col of si_tab  L = ~finite(si_tab(1:endspike-1,2));  % selection -- the max is among these  q = si_tab(1:endspike-1, 3);		% use the pvals from the pdf to arbitrate  % it is the val that is the min on the pdf  ibest = find(q ==  min(q(L)));else  ibest = find(si_tab(1:endspike-1,2) == max(si_tab(1:endspike-1, 2)));end	startspike = ibest;startspike_time = s(startspike);endspike_time = s(endspike);tb = [startspike_time endspike_time];	% return valssnumb = [startspike endspike];% Next job is to compute significance% What is the SI index for spikes in the burstnsp = endspike - startspike + 1;ttot = s(endspike) - s(startspike);nhat = spikerate * ttot/1000;p_burst = 1 - poisscdf(nsp, nhat);si_burst = -log(p_burst);signif_burst = p_burst < 0.005;  %   Criterion used by Hanes & Schall% Next job is to decide if something happened before the burst.% Or, in the case that the burst was not significant, we still want to % know when the discharge was significantly elevated above baseline% We apply two different criteria for the beginning of activation, % using pvals of .01 and .05% This just amounts to searching backward on si_tab, starting with startspike% and working our way to the 1st spike of the train.if signif_burst  pcrit = .01;else  pcrit = .05;endif startspike == 1  % we're done   % fill in our answers -- in progress  begin_act = 1;else  prelude = flipud(si_tab(1:startspike, :));    nfirst = min(find(prelude(:,3) > pcrit));    % I have added 1 because we are searching (backward) for the first spike  % that is *not* part of the significant elevation.     if isempty(nfirst)    % never found a value that exceeds pcrit    begin_act = 1;  else    begin_act = prelude(nfirst,1) + 1; % spike number   endend% The algorithm also identifies the end of the activation period beginning% with the burst.  Here we start with the 1st spike in the burst and work% our way to the end of the spike train.  Matt, correct me if I'm wrong, but% I don't think we have ever calculated the surprise indices this way, up to% this point.% we had saved a version of g, called g0% Take the part from startspike to the endg = g0(find(g(:,2)==startspike):nspikes,:);si_tab = zeros(size(g,1),3);	% allocate the array -- 1 row for each spikenst2end = size(g,1);		% number from startspike to end of trainfor i = 1:nst2end  nsp = nst2end - i + 1;   	% number of spike from this point in train  ttot = g(nst2end,1) - g(i,1);   % time left from this point to endspike  nhat = spikerate * ttot;  si_tab(i,:) = [g(i,2) -log(1 - poisscdf(nsp,nhat)) poisspdf(nsp, nhat)];end% To find the end of activation, we just look for the 1st place where the% significance falls below our criterion.  Hanes uses a different criterion% depending on whether the burst was significant, and at what level.if endspike == nspikes  % we're done.  The end of the burst is the end of the train  end_act = endspike;else  nfirst = min(find(si_tab(:,3) > pcrit & si_tab(:,1)>endspike));    if isempty(nfirst)    % never found a value that exceeds pcrit    end_act = nspikes;  else    % note, we subtract 1 because that's the last spike that was part of the    % elevated discharge epoch.    end_act = si_tab(nfirst,1) - 1; % spike number   endendtact = [s(begin_act) s(end_act)];snumact = [begin_act end_act];if nargin > 2  if plotopt    plot(s,ones(size(s)),'.'),    set(gca,'YColor','k','Box','off')    title('spikes versus time')    hold on;    plot(tb,[.995 .995],'r+')    plot(tact,[1.005 1.005],'g+')    set(gca,'YLim', [.9 1.1])    hold off;  endend