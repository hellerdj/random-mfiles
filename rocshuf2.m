function [roc1, roc2, p, dcrit05] = rocshuf2(x1,b1,x2,b2,nsims,dfname)% [roc1,roc2,p,dcrit05] = rocshuf2(x1,b1,x2,b2,nsims,dfname)% 	takes two distributions which are themselves split into signal and% 	noise distributions, calculates 2 roc values and their difference,% 	and then performs a bootstrap calculation to estimate the% 	distribution of roc differences under the null hypothesis that the% 	distributions of signal and noise came from a single pair.  The% 	routine computes z-transforms on x1 and x2 prior to performing any% 	of this because the technique only works if these parent% 	distributions share the same mean.% % INPUT% ~~~~~% x1,b1  responses and sorting arrays.  b1 is a list of 1's and 0's% x2,b2  same thing for the second pair of distributions% nsims  number of points in the bootstrap (2000 is a good idea)% dfname string containing filename for matlab storage of variable d,% 	 the distributin of ROC area differences (absolute vals) under the% 	 null hypothesis. [] means don't store%% Output% ~~~~~~% roc1	roc from x1  sorted by b1% roc2	roc from x2 sorted by b2% p	probability of getting a difference of roc vals under the% 	hypothesis that x1|b1=1 and x2|b2=1 were really the same% 	distribution, and the same for b1=0, b2=0% dcrit05 tells the critical difference necessary to achieve .05 level.% note: /home/monkeybiz/mike/mat/mfiles must be in the matlab path	% fake data to test%$$$ N = 100%$$$ x1 = [randn(N,1);randn(N,1) + .1];%$$$ x2 = [randn(N,1);randn(N,1)- .1];%$$$ b1 = [zeros(N,1); ones(N,1)];%$$$ b2 = [zeros(N,1); ones(N,1)];%$$$ nsims = 1000%$$$ pathmike%$$$ !cp /data/ken/soc/ztrans/zt.onrf a.dat%$$$ !cp /data/ken/soc/ztrans/zt.offrf b.dat%$$$ load a.dat%$$$ load b.dat%$$$ %$$$ whos%$$$ %$$$ x1 = a(:,1);%$$$ b1 = a(:,2);%$$$ x2 = b(:,1);%$$$ b2 = b(:,2);m1 = mean(x1);m2 = mean(x2);s1 = std(x1);s2 = std(x2);%$$$ z1 = (x1-mean(x1)) / std(x1);%$$$ z2 = (x2-mean(x2)) / std(x2);x1 = (x1-m1)/s1;x2 = (x2-m2)/s2;% We must deal with row vectors for roc.reshape(x1,1,length(x1));reshape(b1,1,length(b1));reshape(x2,1,length(x2));reshape(b2,1,length(b2));%$$$ if size(x1,2) == 1 & size(x1,1)>1%$$$   x1 = x1';%$$$   b1 = b1';%$$$ end%$$$ if size(x2,2) == 1 & size(x2,1)>1%$$$   x2 = x2';%$$$   b2 = b2';%$$$ endsize(x1);size(x2);size(b1);size(b2);% vectors must be row vectorsroc1 = rocN(x1(b1==1),x1(b1==0),100);roc2 = rocN(x2(b2==1),x2(b2==0),100);% form arrays under null hypothesis; call them x and y% these are combined distributions of z's sorted by signal v. noise (or% choice in case of SOC) combined from the two data sets.% Note that the x distribution comes from points for which the sorting% binary value is 0.x = [x1(b1==0)' x2(b2==0)'];y = [x1(b1==1)' x2(b2==1)'];sizx = size(x);sizy = size(y);% we want to conserve the number of x1|b1==1 etc.  Let's get thesenb11 = sum(b1==1);nb10 = sum(b1==0);nb21 = sum(b2==1);nb20 = sum(b2==0);xlen = length(x);ylen = length(y);% notice that xlen = nb10 + nb20.  To make a random sort of x into two% arrays of proper size, we just randomly shuffle a list of integers 1:xlen% and then take the 1st nb10 and last nb20 of them as indices into x.  That% would make a random concoction of two sub-distributions from the parent% distribution, x.  Of course, we do the same for y.nx = [1:xlen]';				% these will be used for selectionny = [1:ylen]';d = zeros(nsims,1); 			% allocate differences arrayfor i = 1:nsims  L1 = [nx rand(size(nx))];  q = sortXbyColI(L1,2);		% random sort of indices  % sizq = size(q)  L = q(1:nb10,1); 			% use 1st nb10 of these to make x1  qx1 = x(L);  L = q(nb10+1:xlen,1);			% remainder of random indices to x  qx2 = x(L);  % Now do the same for the b==1 distribution  L1 = [ny rand(size(ny))];  q = sortXbyColI(L1,2);  L = q(1:nb11,1);  qy1 = y(L);  L = q(nb11+1:ylen,1);  qy2 = y(L);  r1 = rocN(qy1,qx1,100);  r2 = rocN(qy2,qx2,100);  %  d(i) = abs(rocN(qx1,qy1,100) - rocN(qx2,qy2,100));  d(i) = abs(r2 - r1);  [i r1 r2 d(i)];enddroc = abs(roc1 - roc2);p = sum(d >= droc)/nsims;d = sort(d);dcrit05 = d(.95*nsims);if nargin < 6  save /home/monkeybiz/mike/rocsim/soc/rocshuftmp.mat delseif ischar(dfname)  s = sprintf('save %s.mat d',dfname);  eval(s);end