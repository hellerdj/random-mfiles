function [t,c,jpsth] = ccg2(s0,s1,tmaxSec,hwidthMsec)%	[t,c,jpsth] = ccg2(s0,s1,tmaxSec,hwidthMsec)%		computes a ccg using joint psthh%		s0 and s1 are matrices containing spike arrival times%			in seconds.  Each row is a trial, corresponding%			in the two arrays.  The arrays are padded with%			zeros.%		tmaxSec is the max time of a trial in seconds%			max(s0(:);s1(:)) should work. But usually %			it's simpler to specify .5 for example%		hwidthMsec is the amount of time on either side of 0%			that we will calculate the ccg.  The joint psth%			covers the entire 0..tmaxSec range.%	Return vals:%		t is an array of times for the ccg%		c is an array of corresponding values in spikes/sec%			stairs(t,c) plots the ccg%		psth is a sparse matrix containing the joint psth%%					M.N. Shadlen  (2/25/94)res = .001;sf = 1/res;n = tmaxSec * sf + 1;ntrials = size(s0,1)if ntrials ~= size(s0,1)  sprintf('Error: number of trials must be same in s0 and s1');  returnend% copy inputs arrival times and get rid of any outside the time ranget12s = sparse(n,n);	% initialize the joint psth%k = 1%tmaxSec = .5%size(s0)t = -hwidthMsec:hwidthMsec;	% initialize time array (msec)for k = 1:ntrials  %k  % select the rows of the spike arrays, and prune 0's and vals > tmax  xx = s0(k,s0(k,:) <= tmaxSec & s0(k,:) > 0);  yy = s1(k,s1(k,:) <= tmaxSec & s1(k,:) > 0);  %size(xx)  %size(yy)  t1s = sparse(1,round(xx*sf)+1,1,1,n);  t2s = sparse(1,round(yy*sf)+1,1,1,n);  % increment the joint psth  t12s = t12s + t1s'*t2s;endc = zeros(1,length(t));for i = 1:length(t)	d = diag(t12s,t(i)); 	c(i) = full(sum(d)/(length(d)*ntrials*.001));end% min(c)% max(c)