function [w,blob,Fblob,F_ind] = ConvWithxytBlob(ind,arg2,sx,y0,sy,t0,st)% ConvWithxytBlob% Takes xyt cube, ind, which is a logical sampling array (indicator% function) returns a weighting function, w, which is a convolution between% ind and 3-d gaussian function, blob.  % The function can be called in 2 ways% [w,blob,Fblob,F_ind] = ConvWithxytBlob(ind,x0,sx,y0,sy,t0,st)%    creates the blob using offsets and stdevs for x, y and t.  These values%    are given in pixels (in units of the indicator function array). In%    addition to the weighting function, W, the routine returns the gaussian%    blob, BLOB, its fourier transform (Fblob) and and the fourier transform%    of ind (F_ind).  The two FFTs are compex 3-d arrays.% w = ConvWithxytBlob(ind,Fblob)%    can be used if you already know the FFT of the blob function.  This is%    a faster version since it need only compute the FFT of the ind array,%    multiply FFTs and compute the inverse.% In both cases, w is normalizes so that the total sum(w(:)) is equal to % sum(index(:)). %    % 10/1/97 mns wrote it% 10/17/97 mns fixed the fftshift logic% could send the covarmtx and use quadratic form.% $$$ ind = rand(64,64,32) < .001;% $$$ sx = 1					% sx in units of array ind% $$$ sy = 2% $$$ st = 8% $$$  x0 = 0% $$$  y0=0% $$$  t0 = 2% $$$  error('forgot to comment out devel lines')% $$$ subplot(2,2,1)% $$$ imagesc(squeeze(ind(:,:,14)))if nargin < 2 | (nargin > 2 & nargin < 7)  error('Call with 2 or 7 arguments')elseif nargin == 2  Fblob = arg2;				% arg 2  % second argument should the FFT of the blob  if any(size(Fblob)~=size(ind)) | isreal(Fblob)    error('Arg2 should be fourier transform of blob')  endelseif nargin > 2  % compute the gaussian kernel    x0 = arg2;     nx = size(ind,1);  x = linspace(-1,1,nx);			% x axis on -1..1  dx = diff(x([1 2]));			% sample interval  ssx = sx * dx; 				% convert to -1..1  x0 = x0*dx;				% same    ny = size(ind,2);  y = linspace(-1,1,ny);			% y axis on -1..1  dy = diff(y([1 2]));			% sample interval  ssy = sy * dy; 				% convert to -1..1  y0 = y0*dy;				% same    nt = size(ind,3);  t = linspace(-1,1,nt);			% t axis on -1..1  dt = diff(t([1 2]));			% sample interval  sst = st * dt; 				% convert to -1..1  t0 = t0*dt;				% same  [X Y T] = ndgrid(x,y,t);  % size(X)  blob = fftshift(exp(- ( ((X-x0)/ssx).^2 + ((Y-y0)/ssy).^2 +...      ((T-t0)/sst).^2)));  Fblob = fftn(blob);endF_ind = fftn(ind+0);% i think we no longer need to fftshift here (but you do to see the blob)w = real(ifftn(Fblob .* F_ind));tot1 = sum(ind(:));totw = sum(w(:));w = w * (tot1/totw);% $$$ % $$$ colormap(hot)% $$$ figure(1)% $$$ tframe = 10% $$$ Rx = 40:60;% $$$ Ry = 100:120;% $$$ subplot(2,2,1)% $$$ imagesc(squeeze(ind(:,:,tframe)))% $$$ subplot(2,2,2)% $$$ imagesc(squeeze(ind(Ry,Rx,tframe)))% $$$ subplot(2,2,3)% $$$ imagesc(squeeze(w(:,:,tframe+6)))% $$$ subplot(2,2,4)% $$$ imagesc(squeeze(w(Ry,Rx,tframe+6)))% $$$ % $$$ figure(2)% $$$ imagesc(squeeze(blob(1,:,:)))% $$$ plot(fftshift(squeeze(blob(1,1,:)))),set(gca,'XLim',[1 32])% $$$ plot((squeeze(blob(1,1,:)))),set(gca,'XLim',[1 32])% $$$ plot((squeeze(blob(:,1,6)))),set(gca,'XLim',[1 20])% $$$ plot((squeeze(blob(1,:,6)))),set(gca,'XLim',[1 20])