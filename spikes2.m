% This is Matt Leon's working version of the Hanes algorithm.  It makes and% analysized the spikes.  MNS is splitting this into hanes.m and% test_hanes.mepochs = [1.2 .4 1.2]s = make_exp_spikes([10 200 10], epochs);ssav = s;%returnduration = sum(epochs)% if we want to make a ramp then we use the s vector below with the duration% proceeding it.%s = make_exp_spikes(linspace(5,400,20),.05*ones(20,1));% duration=1       play_spikes(s,2); g=[s'*.001 (1:length(s))'];%makes a column vector of s and adds a %second column which includes the spike number.s2=[s'*.001 (1:length(s))'];%This is just a replica of g so that you can%go back later if you wish to see at what point in time the spikes occurred.spikerate=length(s)/duration;isi = diff(s)*.001;% diff(s) computes the interspike interval between 2 adjacent spikes by% taking the difference in the times of occurrence for the two spikes%subplot(1,2,1)% hist(isi*1000,30)%title('interspike interval histogram')%xlabel('interspike interval in msec')%ylabel('frequency of occurence')%subplot (1,2,2)plot(s,ones(size(s)),'.'),set(gca,'YColor','k','Box','off')title('spikes versus time')% it is common to compute the std of the interspike interval distribution and% to divide by the mean interval -- that's called the CV_isi (coeff. of % variation).% for an exponential distribution, this value should be 1cv = std(isi)/mean(isi);%make a new matrix for calculating SI values as used by Hanes et al,1993a=[isi(:) (2:length(s))']; % make a 2 column vector from isi by taking its% transpose.  The second column are the ACTUAL spikes numbered as they occur % in the train. It starts at 2 because 2 spikes must have occurred in order % to calculate the first isi value.while a(1,1)>(1/spikerate)  a(1,:)=[];end;% this starts at the beginning of the a matrix and delete rows until it % comes to a value(isi) that is equal to or less than 1/spikerate, that is,% the predicted interspike interval.  This vector will serve as% column 1 and 2 of matrix M below which will store all the relevant info.b=cumsum(a(:,1)); % this will be column 3 of data matrix containing all t % intervals% As part of Hanes' algorithm, once you've gotten to the first isi that is <=% your predicted isi, you move on to the next spike and add that isi value% to T.  You need T to calculate the expected % number of spikes given the amount of time (your T value) that has passed.c=(2:(size(b,1)+1))'; % this will be column 4 of data matrix containing the % spike number of the train.  it starts at 2 because 2 spikes must have % occurred in order to calculate the first isi value in column 2d=1-(poisscdf(c,(spikerate*b))); % probabilities of getting the number of% spikes% in c or greater based on the poisson distribution with a mean spikerate of % average_rate*T (added up isi's)e=-log(d(2:length(d))); 		% Hanes SI index value likec = poisspdf(c,(spikerate*b));if any(~finite(e))  % we have some extreme vals  % The biggest lies among the infinite  vals for e  j = ~finite(e);  % selection -- the max is among these  q = poisspdf(c(2:length(c)),(spikerate*b(2:length(b))));  % it is the val that is the min on the pdf  ibest = find(q ==  min(q(j)))+1;else  ibest = find(e == max(e(2:length(e))))+1;end	% The place where SI is maximal is the last spike of the burst.% According to Hanes' algorithm the very first SI value is excluded from % this search.  This is why the e vector is 1 cell shorter than the other % vectors (a,b,c,d,L).   Because I had to exclude the first cell I must add % 1 to ibest in order to obtain the correct spike number in vector a.endspike=a(ibest,2);%According to Hanes' I now am supposed to go to the very last spike in the %train and calculate SI for the T interval from the last spike to the%first spike after target presentation, which in this case is just %the first spike in the train.estspike_count=spikerate*(s(1,length(s))-s(1,1))*.001;si1 = -log(1-(poisscdf(length(s),estspike_count)));p1 = poisspdf(length(s),estspike_count);g(find(g(:,2)==endspike)+1:length(g),:)=[];% this deletes all rows of g AFTER% the endspike row.  In Hanes' algorithm we now want start deleting spikes% from the beginning of the train and continuously calculate SI until we come% to the spike designating the end of the burst (endspike)h = 1:endspike; % we're going to use this matrix to record our SI values that% we calculated as we continued to delete spikes from the beginning of the % train.  The highest number in row 1 of matrix h corresponds to the% spike representing the end of the putative burst.h(2,1) = si1; % this is the SI that we calculated going from the last spike in% the spike train to the first spike in the train after target presentation% h(2,endspike) = M(find(M(:,7)==f),6);h(2,endspike) = e(ibest);h(3,1) = p1;%h(3,endspike) = f;h(3,endspike) = likec(ibest);g(1,:)=[]; 				% delete the very first spikewhile g(1,2)<endspike  si=-log(1-(poisscdf(length(g),(spikerate*(g(length(g),1)-g(1,1))))));  p = poisspdf(length(g),(spikerate*(g(length(g),1)-g(1,1))));  h(2,g(1,2))=si;  h(3,g(1,2))=p;  g(1,:)=[];end;% length(g) = spikecount% g(length(g),1)-g(1,1) = train_duration%v=max(h(2,1:endspike-1)); %finds where SI was maximized and designates the %beginning of the burst.if any(~finite(h(2,1:endspike-1)))  % we have some extreme vals  % The biggest lies among the infinite  vals for h(2,endspike-1)  L = ~finite(h(2,1:endspike-1));  % selection -- the max is among these  q = h(3,1:endspike-1);  % it is the val that is the min on the pdf  ibest = find(q ==  min(q(L)));else  ibest = find(h(2,1:endspike-1) == max(h(2,1:endspike-1)));end	startspike=ibest;  % for rounding problem.  If works will delete startspike formula above.SIS=[startspike,endspike;h(2,startspike),h(2,endspike);s(1,startspike)*.001,s(1,endspike)*.001];% SIS is a matrix containing the spike (numbered as it appears in train) at% the beginning of the burst and the spike at the end of the burst in row 1.% row 2 are the SI (surprise index) values and row 3 are the points in % time at which the spikes occurred. ......signifSI=-log(.005);burstSI = ...    -log(1-(poisscdf(endspike-startspike+1,spikerate*(SIS(3,2)-SIS(3,1)))));  burst1SI=burstSI;burst2SI=burstSI;% burstSI corrsponds to the SI calculated from the end of the burst to the % beginning of the burst, that is, from startspike to endspike (see part 4% of Hanes et al algorithm).  find(s2(:,2)==startspike);find(s2(:,2)==endspike);% in order to carry out steps 4 and 5 of Hanes paper we need to know what % level of significance to use for the BurstSI (see paper).  We have to keep % adding on the spikes that occur before "startspike" until the SI falls below% significance.  If a burst never occurs because either the startspike SI or% the endspike SI is not significant, then we will use p<.05 for our burstSI.% If a burst did occur then we will use p<.01 for our burstSI.if SIS(2,1) < signifSI | SIS(2.2) < signifSI  refSI = -log(.05);else  refSI = -log(.01);end startspike_Time = s2(startspike,1); % I should use these above when I first calculate burst1SI.endspike_Time = s2(endspike,1);while startspike > 0 & burst1SI > refSI  burst1SI = -log(1-(poisscdf(endspike-startspike+1,spikerate*(endspike_Time-s2(startspike,1)))));  startspike = startspike-1;end;		% Once the above function stops running (burst1SI is no longer greater than% refSI, the value of startspike will refer to the spike in the train at % which the SI first fell below the desired significance level (refSI).% Therefore, startspike + 1 will refer to the spike at which the train became % significantly elevated, that is, the beginning of activation.beginact_spike = startspike+1;% The following 4 values now need to be reset to their original values so that% I can carry out step 5 in Hanes algorithm and calculate the end of activation.startspike=SIS(1,1); endspike=SIS(1,2);	 startspike_Time = s2(startspike,1);endspike_Time = s2(endspike,1);while endspike < (length(s2)+1) & burst2SI > refSI	  burst2SI = -log(1-(poisscdf(endspike-startspike+1,spikerate*(s2(endspike,1)-startspike_Time))));  endspike = endspike+1;end	endact_spike=endspike-1;SIS(4,1)=beginact_spike;SIS(4,2)=endact_spike;SIS(5,1)=s(1,beginact_spike)*.001;SIS(5,2)=s(1,endact_spike)*.001%SIS is a matrix containing the spike (numbered as it appears in train) at%the beginning of the burst and the spike at the end of the burst in row 1.%row 2 are the SI (surprise index) values and row 3 are the points in %time at which the spikes occurred. Row 4 contains the spike at the beginning%of activation and the spike at the end of activation.  Row 5 contains the %exact times that those spikes occured.     signifSI=-log(.005)total_spikes=length(s)