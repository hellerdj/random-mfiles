function [sU1,sU1n,sU2,sU2n,T,ras1,ras1n,ras2,ras2n] = sumGamTrains3(sr1, gamma_order, tdur, N_in, cominpE, cominpI)% [sU1,sU1n,sU2,sU2n,T,ras1,ras1n,ras2,ras2n] = sumGamTrains3(sr1, gamma_order, tdur, N_in, cominpE, cominpI)%% Generate spike trains for ccg model. Uses gamma distributed interspike% intervals.  The routine generates the sums of spikes in 1 msec bins% for a duration of tdur sec.  N_in neurons are simulated in each of 4 sets % representing excitatory input to neurons 1 and 2 and the inhibitory input% to neurons 1 and 2. Some fraction of the excitation and inhibition % may be specified as shared.%% Version 2.  Faster.  Adding capacity to return rasters.% Version 3.  Faster yet?%% Inputs% % sr1  			spike rate in sp/sec% gamma_order   the parameter of the gamma -- 1 means exponential, <1 makes%								more regular spike trains.% tdur  		duration of spike train in sec (should be integer)% N_in   		number of excitatory inputs (program uses same for inhib)% cominpE  	fraction of shared excitatory inputs% cominpI      "         "     inhibitory inputs%% Output% sU1			sum of spikes in 1 ms bins for the N_in excitatory inputs to neuron 1% sU1n		sum of spikes in 1 ms bins for the N_in inhibitory inputs to neuron 1% sU1			sum of spikes in 1 ms bins for the N_in excitatory inputs to neuron 2% sU1n		sum of spikes in 1 ms bins for the N_in inhibitory inputs to neuron 2% T				time vector, used by simulink%% e.g., tdur might be 2 sec, N_in might be 100 or 300 % run this after setting the vars. Then run the simulink ccg_rw_sim% then call [lambdahat, lambdaci, phat, pci] =  Uout2ISIhist(U1out,U2out)%% Note: this routine turned out to be a pain in the ass to write.  I kept% running out of memory.  That's why I adopted the 1 sec steps.% 7/13/96 mns wrote it% 8/19/96 mns faster algorithm (hardly)guessN = ceil(N_in*tdur*sr1 + 3*sqrt(N_in*tdur*sr1) )u1 = nan*ones(1,guessN);u1n = nan*ones(1,guessN);u2 = nan*ones(1,guessN);u2n = nan*ones(1,guessN);T = [.001:.001:tdur]';% initialize the counterslo1 = 1; lo1n = 1; lo2 = 1; lo2n = 1;% I have a problem making more than 10 s worth of gamma spikes.  So I'm% going to introduce a work-aroundfor i = 1:N_in  gam_spikes = fast_gam_spikes(sr1,gamma_order,tdur)/1000;  hi = lo1 + length(gam_spikes)-1;  if hi > lo1    u1([lo1:hi]) = gam_spikes;    ras1([lo1:hi]) = i * ones(length(gam_spikes),1);    lo1 = hi+1;  end  if i > ceil(cominpE * N_in)    % Make new spikes for unit 2; otherwise use the same input for both trains    gam_spikes = fast_gam_spikes(sr1,gamma_order,tdur)/1000;  end  % gam_spikes for unit 2 gets added to u2  hi = lo2 + length(gam_spikes) - 1;  if hi > lo2    u2(lo2:hi) = gam_spikes;    ras2([lo2:hi]) = i * ones(length(gam_spikes),1);    lo2 = hi + 1;  end  % Inhibitory input to unit 1  gam_spikes = fast_gam_spikes(sr1,gamma_order,tdur)/1000;  hi = lo1n + length(gam_spikes) - 1;  if hi > lo1n    u1n(lo1n:hi) = gam_spikes;    ras1n([lo1n:hi]) = i * ones(length(gam_spikes),1);    lo1n = hi + 1;  end  if i > ceil(cominpI * N_in)    % Make new spikes for unit 2; otherwise use the same input for both trains    gam_spikes = fast_gam_spikes(sr1,gamma_order,tdur)/1000;  end  % gam_spikes for unit 2 gets added to u2n  hi = lo2n + length(gam_spikes) - 1;  if hi > lo2n    u2n(lo2n:hi) = gam_spikes;    ras2n([lo2n:hi]) = i * ones(length(gam_spikes),1);    lo2n = hi + 1;  end  endsprintf('pruning the rasters')if lo1 < guessN  u1(lo1:guessN)=[];  ras1(lo1:guessN)=[];endif lo1n < guessN  u1n(lo1n:guessN)=[];  ras1n(lo1n:guessN)=[];endif lo2 < guessN  u2(lo2:guessN)=[];  ras2(lo2:guessN)=[];endif lo2n < guessN  u2n(lo2n:guessN)=[];  ras2n(lo2n:guessN)=[];endt = T;sprintf('Binning the spikes...this takes some time')[sU1] = hist(u1,T); [sU1n] = hist(u1n,T); [sU2] = hist(u2,T); [sU2n] = hist(u2n,T); % We need the tranposessU1 = sU1';sU1n = sU1n';sU2 = sU2';sU2n = sU2n';% Return the rasters as 2-column vectorsif nargout > 5  ras1 = [u1(:) ras1(:)];  ras2 = [u2(:) ras2(:)];  ras1n = [u1n(:) ras1n(:)];  ras2n = [u2n(:) ras2n(:)];end