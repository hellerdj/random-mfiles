function [alpha, beta, kappa, llik] = quickfit3(data)% QUICKFIT3 fits a 3-parameter weibull function to data using maximum likelihood%	maximization under binomial assumptions.  It uses quick_err3 for%	error calculation.  Data must be in 3 columns: x, %-correct, Nobs%	usage: [alpha, beta, kappa, llik] = quickfit(data)%		alpha and beta are the threshold and slope parameters.%		kappa is the upper asymptote%		llik is the log likelihood of obtaining the data give the fit% update 4/1/95 to use optimization toolbox, contrained fit -- nope%  old code is quickfit_no_opt.m% 12/11/96  jdr & mns fixed guessing bug (we hope) global Data;Data = data;% generate guessq = ones(2,1);% use linear interpolation to guess alpha% next line takes x and %-cor columns, flips them and interpolates along% x to find the value corresponding to .8 correct.  The interpolation% requires monotonic %-cor column, so we sort the matrix 1st.% Remember, it's just a guess.a = find(data(:,2)>.7 & data(:,2)<.9);% b = find(data(:,2)<.8 & data(:,2)>.8);if isempty(a)  q(1,1) = mean(data(:,1));elseif min(data(:,2)) > 0.8  q(1,1) = data(find(data(:,2)==min(data(:,2))),1);elseif max(data(:,2)) >= 0.8  % this bombs if there's nothing greater than 0.8 in the 2nd column  tmpdata = data + [zeros(size(data(:,1))) rand(size(data(:,2)))/100 ...	zeros(size(data(:,3)))];  q(1,1) = table1(sortXbyColI(fliplr(tmpdata(:,1:2)),1),.8);else  q(1,1) = max(data(:,2));end% q(1,1) = table1(sort(fliplr(tmpdata(:,1:2))),.8);% note you can't use the preceding line on data since it will fail if there% are duplicates. That's the point of adding random vals. (This was Greg% Horwitz's idea.trace = 0;tol = .0001;quick = fmins('quick_err3',q,[trace tol]);if quick(1) <= 0  % IT'S A bad fit.  Try another method.  q(1) = .1;  q(2) = .5;  quick = fmins('quick_err3',q);endalpha = quick(1,1);beta = quick(2,1);kappa = quick(3,1);llik = fitfunw(q); 