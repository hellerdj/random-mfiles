function [m,s,n,xmin,xmax,g] = NaNstats(x)% [m s n xmin xmax g] = NaNstats(x)%    calculated the mean of x, removing any NaNs.  If x is a vector, the%    mean, stdev, and number on numerical counts are returned.  If x is a%    matrix then the calculations are done by column and the output is a row%    vector (just like in matlab's mean() routine).%    RETURN values are %    M  mean, a row vector if x is a matrix%    S  stdev, a row vector if x is a matrix%    N  count, a row vector if x is a matrix%    XMAX max, a row vector if x is a matrix%    XMIN min, a row vector if x is a matrix%    G  a 5-vector containing the grand mean, stdev, count, max and min for%    the entire matrix x(:) with nan's removed.%% M. Shadlen 9/26/94%if size(x,1) == 1  % if x is not a matrix, make sure it's a column vector  x = x(:);				endif sum(isnan(x(:))) == 0  % there are no NaN terms.  So use matlab routines.  m = mean(x);  s = std(x);  n = size(x,1) * ones(1,size(x,2));  xmax = max(x);  xmin = min(x);  g = [mean(x(:)) std(x(:)) length(x(:)) max(x(:)) min(x(:))];else  [nr nc] = size(x);  m = zeros(1,nc);			% allocation  s = zeros(1,nc);  n = zeros(1,nc);  xmax = zeros(1,nc);  xmin = zeros(1,nc);  for i = 1:nc    y = x(:,i);    y(isnan(y)) = [];			% remove the nan's    if ~isempty(y)      m(i) = mean(y);      s(i) = std(y);      n(i) = length(y);      xmax(i) = max(y);      xmin(i) = min(y);    else      m(i) = nan;      s(i) = nan;      n(i) = 0;    end  end  % calculate grand mean, stdev, and count  y = x(:);  y(isnan(y)) = [];  g = [mean(y) std(y) length(y) max(y) min(y)];end    