function [C,Q] = structCVM(n,rmax,lamda)%  [C,Q] = structCVM(n,rmax,lamda)%  Returns covariance matrix, C, and its matrix square root, Q.  %  These are structured covariance matrices of size, n by n, in which% the correlation falls off as an exponential as a function of separation of% the indices.  The correlation between i=k and j=k+1 is rmax.  The% correlation between i=k and j=k+v follows decay with space constant,% lamda.  Note that lamda is in units of matrix indices.%% To generate an n-tuple (vector) of random deviates with 0 mean and unit% variance, but with correlation specified in C, simple multiply%   y = Q*x% where x is an n by 1 column vector of *independent* normal deviates with% unit variance and mean 0 (i.e., N{0,1}).% To generate m such n-tuples, simply multiply %   Y = Q*X% where X is an n by m matrix -- essentially the little x above, in m% columns.  When you make this, you will note that the m column vectors in% the output, Y, are like m repetition of the n-tuple pick. The expected% covariance, cov(Y'), is C.  n.b., you must transpose Y so that cov will% respect the column vectors as the repetitions.%% see also meanR, qrancorrelmtx%% 10/30/96 mns and jdr wrote itif nargin < 3  error('structCVM requires 3 inputs')enda = [1:n];A = a(ones(n,1),:);C = exp(1/lamda) * rmax * exp(-abs(A-A')/lamda);Q = sqrtm(C);% more testing% $$$ x = randn(10,100);% $$$ y = Q*x;% $$$ z = eye(10)*x;% $$$ CO = cov(y');% $$$ rho0 = cov2r(cov(z'))% $$$ size(CO)% $$$ CO% $$$ rho = cov2r(CO)% $$$ rm = meanR(y')% $$$ meanR(z')