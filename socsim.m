function [rx,soc, r_xsoc, ave_r, ave_soc] = socsim(ncells,ntrials,rmax,epsilon)% SOCSIM performs a numerical simulation of superneuron superantineuron%	by generating a random covariance structure such that the pairwise%	r values are on the range 0..rmax.  There are ncells neurons and ncells%	antineurons.  Antineurons are assumed to have the same covariance%	structure as the neurons . . . but I intend to elaborate this.%	The routine generates ntrials of data and assigns a behavior %	(1 or 0) if the sum of neurons > sum of antineurons, for each%	trial.  The SOC is computed for each neuron's set of responses%	sorted by the behavior, and is returned as row vector soc.%	A unit's average correlation with all the other units is %	intended to reflect its degree of connectivity and is returned%	as row vector rx.  The correlation between degree of %	connectivity and SOC is the correlation coefficient between%	rx and soc.  It is returned as scalar r_xsoc.%	Finally, the mean r value between all pairs is ave_r. %	The mean SOC is returned as ave_soc.%	Usage: [rx,soc, r_xsoc, ave_r, ave_soc] = rsocsim1(ncells,ntrials,rmax,epsilon)%% ncells = 100;n = ntrials;% rancorrelmtx is a function I wrote.C = rancorrelmtx(ncells,rmax);Q = sqrtm(C);X = Q * randn(ncells,n);Y = Q * randn(ncells,n);% b is a row vector that is 1 if the column of unit responses in X is% larger than the sum over the corresponding column of Y.  It is behavior.b = sum(X) > sum(Y);soc = zeros(1,ncells);	% allocate the soc vectorfor i = 1:ncells	xP = X(i,b);	xN = X(i,~b);	soc(i) = roc(xP,xN);	% next lines are for visual check on these vals	% s = sprintf('soc (unit %d) = %.3f', i,soc(i));	% s	% [bpx,bpy] = bar(xP);	% [bnx,bny] = bar(xN);	% plot(bpx,bpy),hold,plot(bnx,bny),hold off,title(s),pauseendave_soc = mean(soc);Cx = corrcoef(X');	% all r vals between pairsave_r = sum(sum(triu(Cx,1)))/(ncells*(ncells-1)/2);	% average% fprintf('Mean SOC = %g\n', ave_soc);% fprintf('Mean r value between all pairs = %g\n', ave_r);% For any cell, its average r value with all other cells is given byrx = (sum(Cx) - 1) / (ncells - 1);rxe = (sum(C) - 1) / (ncells - 1);	% the expected vals from C% rx is a row vector representing the average r value for each cell.% This is computed from the actual covariance matrix.  Notice that% the unity term is subtracted and the the number of correlations is% ncells - 1.% rxe is the corresponding row vector for the expected average correlation.%  We use the desired covariance matrix C for this.  We can get away with%  this because the covariance matrix is the correlation matrix as we assume%  unity variance on all terms.% There are 2 types of mean square errors we could obtain, mse1 compares% the mean r values.  mse2 compares the individual r values.% Uncomment these if you want to see them.  I have reassured myself% that the mean error is quite low (on order of 1-5%) when 100 or more% trials are used.% mse1 = sum((rxe-rx).^2) / ncells;% mse2 = sum(sum((Cx(1:ncells,1:ncells) - C).^2)) / (ncells^2);h1 = corrcoef([rx;soc]');% fprintf('Correlation coefficient between a unit''s average r and its SOC = %g\n', h1(1,2));r_xsoc = h1(1,2);